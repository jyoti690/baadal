(dp1
S'output'
p2
S"<type 'exceptions.Exception'> Versioning for this project requires either an sdist tarball, or access to an upstream git repository. Are you sure that git is installed?"
p3
sS'layer'
p4
S'/home/archer/Documents/web2py/applications/baadal/models/Baadal.py'
p5
sS'code'
p6
S'#!/usr/bin/python\nimport test\nimport logging\nfrom keystoneclient.auth.identity import v2\nfrom keystoneclient import session\nimport os\nimport datetime\n\nclass Machine:\n    def __init__(self, ):\n        self.hostname = ""\n        self.config = {\n                memory : None,\n                storage : None,\n                extra_storage : None,\n                cpu : None,\n                private_ip : None,\n                public_ip : None\n        }\n        \nclass BaadalVM:\n    def  __init__(self, id=None, server=None, conn=None):\n        if id != None and server != None:\n            raise BaadalException(\'Cannot initialise server, please specify either server or id\')\n        else:\n            import novaclient.v2.servers\n            if isinstance(server, novaclient.v2.servers.Server):\n                self.server = server\n                self.__conn = conn\n\n        #create an object corresponding to an existing VM with specified ID\n        #usedb\n        self.name = self.server.name\n        self.id = None\n        self.identity = None\n        self.hostid = None\n        self.vnc_port = None\n        self.purpose = None\n        self.datastore = None\n        self.template_id = None\n        self.expiry_date = None\n        self.start_time = None\n        self.security_domain = None\n        self.snapshots = []\n        #self.server = novaclient.v2.servers.Server\n        pass\n\n    def start(self, ):\n        """\n        starts the Vritual Machine,\n        params: None\n        return: None\n        """\n\n        try:\n            self.server.start()\n        except Exception as e:\n            #debug.log(e)\n            raise BaadalException(e)\n        pass\n\n    def shutdown(self, force=False):\n        """\n        shutdown the Virtual Machine\n        params:\n            force: bool, True for forced shutdown, False for graceful shutdown, default False\n        return: None\n        """\n\n        try:\n            self.server.stop()\n        except Exception as e:\n            #debug.log(e)\n            raise BaadalException(e)\n        pass\n        \n    def reboot(self, soft=True):\n        """\n        reboot the Virtual Machine\n        params:\n            soft: bool, True for soft reboot, False for hard reboot, default True\n        return: None\n        """\n        try:\n            if soft == True:\n                res = self.server.reboot(reboot_type=\'REBOOT_SOFT\')\n            else:\n                res = self.server.reboot(reboot_type=\'REBOOT_HARD\')\n        except Exception as e:\n            #debug.log(e)\n            raise BaadalException(e)\n\n    def delete(self, ):\n        try:\n            res = self.server.delete()\n        except Exception as e:\n            #debug.log(e)\n            raise BaadalException(e)\n        pass\n\n    def createSnapshot(self,snapshot_name=None):\n        try:\n            snapshot_name = snapshot_name or self.server.name + "snapshot" + datetime.datetime.now().isoformat()\n            snapshot_id = self.server.create_image(snapshot_name)\n            snapshot_image = self.__conn[\'nova\'].findImage()\n            return snapshot_id\n            #return Snapshot(snapshot, self.server)\n        except Exception as e:\n            #debug.log(e)\n            raise BaadalException(e)\n        pass\n\n    def refreshStatus(self):\n        #refresh connection to a modified VM\n        self.server = self.server.manager.find(id=self.server.id)\n\n    def migrate(self, target_host, live=False):\n        try:\n            if live == True:\n                res = self.server.migrate(dest)\n            else:\n                res = self.live_migrate(dest)\n        except Exception as e:\n            #debug.log(e)\n            raise BaadalException(e)\n        pass\n\n    def revertSpanshot(self, snapshot_id):\n        #usedb\n        pass\n\n    def getXml(self, ):\n        return self.server.to_dict()\n        pass\n\n    def __getattr__(self, attr):\n        if attr == None:\n            return self\n        if attr is None:\n            return self\n        if attr == \'status\':\n            return self.getStatus()\n        if attr == \'attacheddisks\':\n            return self.attachedDisks()\n        if attr == \'lastsnapshot\':\n            return self.lastSnapshot()\n        else:\n            raise AttributeError\n\n    def getStatus(self, ):\n        STATUS = {\n                \'ACTIVE\' : \'Running\',\n                \'SHUTOFF\' : \'Shutdown\',\n                }\n        self.refreshStatus()\n        return STATUS[self.server.status]\n        pass\n\n    def clone(self, clone_name=None):\n        """\n        create clone of the selected Virtual Machine\n        params:\n            clone_name: name of the new clone VM to be created (optional),\n            an automatically generated name is used if clone_name is not\n            supplied\n        return:\n        """\n\n        #create a snapshot of the  machine\n        #create a new vm using the newly created snapshot\n        #delete the snapshot\n        try:\n            snapshot_id = self.server.create_image("temp")\n            clone_name = clone_name or self.server.name + \'_clone\'\n            flavor_id = self.server.flavor[\'id\']\n            image = self.__conn[\'nova\'].images.find(id=snapshot_id)\n            while image.status != \'ACTIVE\':\n                image = self.__conn[\'nova\'].images.find(id=snapshot_id)\n                pass\n            else:\n                clone = self.server.manager.create(clone_name, image,\n                    self.__conn[\'nova\'].flavors.find(id=flavor_id))\n                while clone.status != \'ACTIVE\':\n                    clone = clone.manager.find(id=clone.id)\n                else:\n                    image.delete()\n                    attached_disks = self.attachedDisks()\n                    for i in attached_disks:\n                        self.__conn[\'cinder\'].volumes.create_server_volume(clone.id, i[\'id\'], i[\'path\'])\n            return clone\n        except  Exception as e:\n        #debug.log(e)\n            raise BaadalException(e)\n        pass\n    \n    def attachedDisks(self,):\n        volume_ids = self.server.__getattr__(\'os-extended-volumes:volumes_attached\')\n        disk_list = []\n        for i in volume_ids:\n            volume = self.__conn[\'cinder\'].volumes.find(id=i[\'id\'])\n            attachments_list = volume.attachments\n            for entry in attachments_list:\n                if entry[\'server_id\'] == self.server.id:\n                    devicepath = entry[\'device\']\n                    disk_list.append({\n                        \'id\' : i[\'id\'],\n                        \'path\' : devicepath\n                        })\n                    pass\n            pass\n        return disk_list\n            \n    def lastSnapshot(self, ):\n        #get the last snapshot of the current VM or return None if no snapshots found\n        #usedb\n        pass\n\n    def attachDisk(self, disk, device_path):\n        """\n        attach a disk to a Virtual Machine\n        params:\n            disk: instance of disk to be attached\n            device_path: path in the system where the disk is to be attached\n        return: \n        """\n\n        try:\n            self.__conn[\'cinder\'].volumes.create_server_volume(self.server.id, disk.id, device_path)\n        except Exception as e:\n            #debug.log(e)\n            raise BaadalException(e)\n        pass\n\n    def update(self, **kwargs):\n        #update metadata/config\n        pass\n    \n    pass\n\nclass Image:\n    def __init__(self, image):\n        self.__image = image\n        self.type = None\n        pass\n    \n    def delete(self):\n        pass\n    \n    pass\n\nclass Disk:\n    def __init__(self, ):\n        pass\n        \n    def attachTo(self, vm, device_path):\n        try:\n            self.__conn[\'cinder\'].volumes.create_server_volume(vm.id, self.id, device_path)\n        except Exception as e:\n            #debug.log(e)\n            raise BaadalException("Failed to attach disk id " + self.id + "to" + vm.id + e)\n        pass\n    \n    def delete(self):\n        pass\n    \n    pass\n\nclass Snapshot:\n    def __init__(self, snapshot_name, vm ):\n        self.vm_id = vm.id\n        self.datastore_id = None\n        self.name = snapshot_name\n        self.type = None\n        self.path = None\n        self.timepath = None\n        pass\n\n    def delete(self, ):\n        pass\n\n    pass\n\nclass Template:\n    def __init__(self, ):\n        self.id = None\n        self.name = None\n        self.os = {\n            os : None,\n            name : None,\n            type : None,\n            edition : None\n        } \n        self.arch = None\n        self.hdd = None\n        self.type = None\n        self.tag = None\n        self.datastore = None\n        self.owner = None\n        self.is_active = None\n\nclass Host(Machine):\n    def __init__(self, ):\n        self.category = None\n        self.status = None\n        self.slot = None\n        self.rack = None\n        self.hosttype = None\n        pass\n    pass\n\nclass Connection:\n    def __init__(self, authurl, tenant_name, username, password):\n        from keystoneclient.auth.identity import v2\n        from keystoneclient import session\n        from novaclient import client\n        from cinderclient import client as cclient \n        auth = v2.Password(auth_url=authurl, username=username,\n                password=password, tenant_name=tenant_name)\n        sess = session.Session(auth=auth)\n        self.__conn = {}\n        self.__conn[\'nova\'] = client.Client(\'2\', session=sess)\n        self.__conn[\'cinder\'] = cclient.Client(\'2\', session=sess)\n        #self.__cinder = cclient.Client("2", session=sess)\n        #self.__conn = client.Client("2", session=sess)\n        pass\n\n    def close(self, ):\n        pass\n\n    def usage(self, attribute_list=None):\n        USAGE_PARAMS = {\n                \'free_storage\' : \'free_disk_gb\',\n                \'used_storage\' : \'local_gb_used\',\n                \'total_storage\' : \'local_gb\',\n                \'free_memory\' : \'free_ram_mb\',\n                \'used_memory\' : \'memory_mb_used\',\n                \'total_memory\' : \'memory_mb\',\n                \'total_vms\' : \'running_vms\',\n                \'load_avg\' : \'current_workload\',\n                \'vcpus\' : \'vcpus\',\n                \'vcpus_used\' : \'vcpus_used\'\n                }\n        values = {}\n        stats = self.__conn[\'nova\'].hypervisor_stats.statistics().to_dict()\n        attribute_list = attribute_list or USAGE_PARAMS.keys()\n        for item in attribute_list:\n            values[item] = stats[USAGE_PARAMS[item]]\n        return values\n        pass\n\n    def baadalVMs(self, ):\n        #return a list of VMs running on the host\n        try:\n            serverList = self.__conn[\'nova\'].servers.list()\n            serverList = [ BaadalVM(server=i, conn=self.__conn) for i in serverList ]\n            return serverList\n        except Exception as e:\n            raise BaadalException(e)\n        \n        #wrap each object of the list of novaclient.v2.servers.Server objects into\n        #a list of BaadalVM objects and return it\n        pass\n\n    def findBaadalVM(self, **kwargs):\n        try:\n            baadalVM = self.__conn[\'nova\'].servers.find(**kwargs)\n            return BaadalVM(server=baadalVM, conn=self.__conn)\n        except NotFound:\n            raise BaadalException("No matching VM found")\n        pass\n\n    def createBaadalVM(self, name, image, template, **kwargs):\n        server = self.__conn[\'nova\'].servers.create(name, image, template, **kwargs)\n        return BaadalVM(server=server, conn=self.__conn)\n        pass\n\n    def createTemplate(self, name, ram, disk, vcpus):\n        try:\n            flavor = self.__conn[\'nova\'].flavors.create(name, ram, disk)\n        except:\n            raise BaadalException("Could not create flavor")\n    \n    def images(self, ):\n        #return a list of all images\n        try:\n            imagesList = self.__conn[\'nova\'].images.list()\n            #imagesList = [ Image(i) for i in imagesList ]\n            return imagesList\n        except Exception as e:\n            raise BaadalException(e)\n        pass\n\n    def findImage(self, **kwargs):\n        try:\n            image = self.__conn[\'nova\'].images.find(**kwargs)\n            #return Image(image)\n            return image\n        except Exception as e:\n            raise BaadalException(e)\n        pass\n    \n    def templates(self):\n        try:\n            templates = self.__conn[\'nova\'].flavors.list()\n            return templates\n        except Exception as e:\n            raise BaadalException(e)\n        pass\n\n    def findTemplate(self, **kwargs):\n        try:\n            template = self.__conn[\'nova\'].flavors.find(**kwargs)\n            return template\n        except Exception as e:\n            raise BaadalException(e)\n        pass\n\n    pass\n\nclass BaadalException(Exception):\n    def __init__(self, msg):\n        self.msg = msg\n        pass\n    \n    def __str__(self):\n        return repr(self.msg)\n        pass\n    pass\n'
p7
sS'snapshot'
p8
(dp9
sS'traceback'
p10
S'Traceback (most recent call last):\n  File "/home/archer/Documents/web2py/gluon/restricted.py", line 227, in restricted\n    exec ccode in environment\n  File "/home/archer/Documents/web2py/applications/baadal/models/Baadal.py", line 4, in <module>\n    from keystoneclient.auth.identity import v2\n  File "/home/archer/Documents/web2py/gluon/custom_import.py", line 95, in custom_importer\n    return base_importer(pname, globals, locals, fromlist, level)\n  File "applications/baadal/modules/keystoneclient/__init__.py", line 35, in <module>\n    __version__ = pbr.version.VersionInfo(\'python-keystoneclient\').version_string()\n  File "/usr/local/lib/python2.7/dist-packages/pbr/version.py", line 457, in version_string\n    return self.semantic_version().brief_string()\n  File "/usr/local/lib/python2.7/dist-packages/pbr/version.py", line 452, in semantic_version\n    self._semantic = self._get_version_from_pkg_resources()\n  File "/usr/local/lib/python2.7/dist-packages/pbr/version.py", line 439, in _get_version_from_pkg_resources\n    result_string = packaging.get_version(self.package)\n  File "/usr/local/lib/python2.7/dist-packages/pbr/packaging.py", line 661, in get_version\n    raise Exception("Versioning for this project requires either an sdist"\nException: Versioning for this project requires either an sdist tarball, or access to an upstream git repository. Are you sure that git is installed?\n'
p11
s.